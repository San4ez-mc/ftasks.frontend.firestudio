# Документація модуля "Аудит"

Цей документ детально описує архітектуру та логіку роботи модуля "Аудит" у припущенні, що вся бізнес-логіка, робота з базою даних та AI виконується на **зовнішньому бекенді**. Next.js додаток виступає як клієнт, що взаємодіє з цим бекендом через проксі-API.

## 1. Загальна концепція

Модуль "Аудит" — це інтерактивний інструмент для проведення бізнес-діагностики. Користувач відповідає на питання AI-консультанта, а система в реальному часі формує структурований звіт та, по завершенню, генерує план робіт.

## 2. Сторінки та їх функціонал (Фронтенд)

### 2.1. Головна сторінка (`/audit`)

Це сторінка зі списком всіх аудитів компанії.

-   **Список аудитів:** Відображає історію аудитів. Дані отримуються через серверний екшен `getAudits()`, який, в свою чергу, робить запит `GET /api/audits` до бекенду.
-   **Кнопка "Розпочати новий аудит":**
    -   Викликає серверний екшен `createAudit()`.
    -   Екшен робить запит `POST /api/audits` на бекенд.
    -   Бекенд створює новий аудит у своїй базі даних і повертає повний об'єкт нового аудиту.
    -   Після успішного створення фронтенд перенаправляє користувача на сторінку `/audit/[new_id]`.

### 2.2. Сторінка проведення аудиту (`/audit/[id]`)

Це основний робочий екран, розділений на дві панелі.

-   **Ліва панель (Діалог):**
    -   **Історія повідомлень:** Відображає листування з AI.
    -   **Ввід відповіді:** Користувач вводить текст або записує аудіо.
    -   **Логіка відправки:** Викликається серверний екшен `continueAudit({ auditId, userAudioDataUri, userText })`.

-   **Права панель (Результати):**
    -   **"Поточна ситуація":** Відображає поле `structuredSummary` з об'єкту аудиту, який оновлюється після кожної відповіді.
    -   **Кнопка "Завершити аудит":** Стає активною, коли з бекенду приходить прапорець `isAiComplete: true`. Викликає екшен `finalizeAudit()`.

## 3. Серверні екшени Next.js (`actions.ts`)

Ці функції є **проксі** між фронтендом та зовнішнім бекендом. Вони **не містять** прямої логіки роботи з БД чи AI.

-   `getAudits()`: Робить `GET` запит на `/api/audits` та повертає список аудитів.
-   `getAudit(id)`: Робить `GET` запит на `/api/audits/{id}`.
-   `createAudit()`: Робить `POST` запит на `/api/audits` для створення нового аудиту.
-   `continueAudit(input)`: Робить `POST` запит на `/api/audits/{id}/continue`, передаючи аудіо або текст користувача. Повертає оновлений об'єкт аудиту.
-   `retryAiProcessing(auditId)`: Робить `POST` запит на `/api/audits/{id}/retry`.
-   `finalizeAudit(auditId)`: Робить `POST` запит на `/api/audits/{id}/finalize`.

## 4. API-ендпоінти та логіка на бекенді

Бекенд відповідає за всю бізнес-логіку, роботу з базою даних та взаємодію з AI (Genkit).

### `GET /api/audits`

-   **Опис:** Отримати список всіх аудитів для компанії, до якої належить користувач (визначається з JWT).
-   **Логіка бекенду:**
    1.  Валідувати JWT.
    2.  Виконати `SELECT * FROM audits WHERE company_id = ?` до своєї бази даних.
    3.  Повернути масив об'єктів аудиту.

### `POST /api/audits`

-   **Опис:** Створити новий аудит.
-   **Логіка бекенду:**
    1.  Валідувати JWT.
    2.  Створити новий запис в таблиці `audits` з початковими даними: `isCompleted: false`, `isAiComplete: false` та перше вітальне повідомлення в `conversationHistory`.
    3.  Повернути повний об'єкт створеного аудиту зі статусом 201.

### `POST /api/audits/{id}/continue`

-   **Опис:** Продовжити діалог аудиту.
-   **Тіло запиту:** `{ "userAudioDataUri": "...", "userText": "..." }`
-   **Логіка бекенду:**
    1.  Валідувати JWT та перевірити, чи має користувач доступ до аудиту `{id}`.
    2.  **(Якщо є `userAudioDataUri`) Транскрипція:** Зробити запит до Genkit (`gemini-1.5-flash-latest`) для перетворення аудіо в текст.
    3.  Зберегти відповідь користувача (транскрибовану або текстову) в базу даних, додавши її до поля `conversationHistory` в записі аудиту.
    4.  **Виклик AI-логіки:** Викликати потік Genkit `getNextAuditStep(updatedHistory, currentSummary)`, передавши поточну історію та резюме з бази даних.
    5.  **Обробка відповіді AI:** Отримати від AI `aiResponseText`, `updatedSummary`, `isComplete`.
    6.  Зберегти відповідь AI та оновлене резюме (`updatedSummary` і `isAiComplete`) в базу даних.
    7.  Повернути повний, оновлений об'єкт аудиту.

### `POST /api/audits/{id}/retry`

-   **Опис:** Повторно запустити AI-обробку для останнього повідомлення користувача.
-   **Логіка бекенду:**
    1.  Дістати з бази даних останнє повідомлення користувача.
    2.  Повторити кроки 4-7 з ендпоінту `/continue`.

### `POST /api/audits/{id}/finalize`

-   **Опис:** Завершити аудит та згенерувати план робіт.
-   **Логіка бекенду:**
    1.  Отримати фінальний `structuredSummary` з бази даних для аудиту `{id}`.
    2.  **Виклик AI-логіки:** Викликати потік Genkit `generateWorkPlanFlow({ structuredSummary })`.
    3.  Зберегти згенерований `workPlan` та встановити `isCompleted: true` для запису аудиту в базі даних.
    4.  (Опціонально) Створити окремий запис у таблиці `audit_results` для зберігання фінальних, незмінних результатів.
    5.  Повернути фінальний, повний об'єкт аудиту.

## 5. Потоки штучного інтелекту (Genkit) - на стороні бекенду

-   **Транскрипція:** Модель `gemini-1.5-flash-latest` з простим промптом "Транскрибуй це аудіо...".
-   **`conversational-audit-flow`:** Отримує історію та резюме, повертає наступне питання та оновлене резюме.
-   **`work-plan-flow`:** Отримує фінальне резюме, повертає масив об'єктів плану робіт.

## 6. Структура даних у базі даних бекенду (приклад для SQL)

### Таблиця `audits`

| Стовпець            | Тип               | Опис                                               |
| ------------------- | ----------------- | -------------------------------------------------- |
| **id**              | `VARCHAR` / `UUID` | **Primary Key**                                    |
| **company_id**      | `VARCHAR` / `UUID` | **Foreign Key** до `companies.id`                  |
| created_at          | `TIMESTAMPZ`      | Час створення                                      |
| conducted_by_id     | `VARCHAR` / `UUID` | **Foreign Key** до `employees.id`                  |
| is_completed        | `BOOLEAN`         | Чи завершено аудит повністю                        |
| is_ai_complete      | `BOOLEAN`         | Чи вважає AI, що всі питання задано                |
| conversation_history| `JSONB`           | Масив об'єктів `{ "role": "...", "text": "..." }`  |
| structured_summary  | `JSONB`           | JSON-об'єкт з результатами в реальному часі        |
| work_plan           | `JSONB`           | Масив об'єктів з фінальним планом робіт            |

### Таблиця `audit_results` (опціонально, для довготривалого зберігання)

-   Містить фіналізовані, незмінні копії `structured_summary` та `work_plan`.

